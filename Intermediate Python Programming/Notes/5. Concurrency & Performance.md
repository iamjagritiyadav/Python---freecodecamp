# Concurrency & Performance

# Threading vs Multiprocessing

Concurrency → Managing multiple tasks at once.
Parallelism → Executing multiple tasks at the exact same time.

Python supports both using:

* threading module
* multiprocessing module

---

# The GIL (Global Interpreter Lock)

The most important concept.

CPython has a Global Interpreter Lock (GIL).

What it does:

* Only ONE thread executes Python bytecode at a time.
* Even on multi-core CPUs.

Why?

* Simplifies memory management
* Prevents race conditions in memory

Impact:

* Multithreading is NOT truly parallel for CPU-bound tasks.
* It works well for I/O-bound tasks.

---

# Multithreading

Threads share:

* Same memory space
* Same variables
* Same process

---

## Basic Example

```python
import threading


def task():
    print("Running")

thread = threading.Thread(target=task)
thread.start()
thread.join()
```

---

## When to Use Threads

Good for I/O-bound tasks:

* File operations
* API calls
* Database queries
* Network requests

Because while one thread waits, another runs.

---

# Race Conditions

Occurs when:
Multiple threads access shared variable and modify it simultaneously.

Example problem:

```python
counter += 1
```

This is NOT atomic.
It involves:

1. Read value
2. Modify
3. Write back

Another thread may interfere.

---

# Locks

To prevent race conditions.

```python
lock = threading.Lock()

with lock:
    counter += 1
```

Lock ensures only one thread enters critical section.

Other synchronization tools:

* RLock
* Semaphore
* Event
* Condition

---

# Multiprocessing

Each process:

* Has separate memory
* Has its own Python interpreter
* No shared GIL

True parallel execution.

---

## Basic Example

```python
from multiprocessing import Process


def task():
    print("Running")

process = Process(target=task)
process.start()
process.join()
```

---

## When to Use Multiprocessing

Best for CPU-bound tasks:

* Data processing
* Machine learning computations
* Image processing
* Large mathematical calculations

---

# Inter-Process Communication (IPC)

Since memory is separate, processes cannot directly share variables.

Methods:

* Queue
* Pipe
* Shared memory

Example:

```python
from multiprocessing import Queue
```

---

# Process Pools

Spawning processes repeatedly is expensive.

Use Pool:

```python
from multiprocessing import Pool


def square(x):
    return x*x

with Pool(4) as p:
    results = p.map(square, [1,2,3,4])
```

Benefits:

* Reuses worker processes
* Efficient task distribution

---

# ThreadPool vs ProcessPool

ThreadPool:

* Shared memory
* Affected by GIL
* Lightweight

ProcessPool:

* Separate memory
* True parallelism
* Heavier but powerful

---

# Deadlocks

Happens when:
Thread A waits for resource held by Thread B
Thread B waits for resource held by Thread A

Program freezes.

Avoid by:

* Consistent lock ordering
* Timeout usage
* Minimizing critical sections

---

# Performance Guidelines

Use Multithreading if:

* Task is I/O-bound
* Network heavy
* Waiting-heavy

Use Multiprocessing if:

* Task is CPU-heavy
* Uses large numerical computations

Avoid concurrency if:

* Overhead is larger than work itself

---

# Summary

GIL → Only one thread executes Python bytecode at a time
Threads → Good for I/O-bound tasks
Race conditions → Prevent using locks
Processes → True parallel CPU execution
Process pools → Efficient large-scale parallel processing

Mastering concurrency allows you to write scalable, high-performance systems.
